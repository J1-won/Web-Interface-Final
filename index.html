<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Brain</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #loading-status {
            color: #4ecdc4;
            margin-top: 8px;
            font-size: 14px;
        }
        .city-label {
            position: absolute;
            color: #4cf3ff; 
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer; 
            transform: translate(-50%, -150%); 
            opacity: 0;
            transition: opacity 0.3s;
            user-select: none;
        }
        button {
            background-color: #333;
            color: white;
            border: 1px solid #4cf3ff;
            padding: 5px 10px;
            cursor: pointer;
        }
        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        #back-to-earth-btn {
            background-color: #222;
            color: #4cf3ff;
            border: 1px solid #4cf3ff;
            padding: 6px 12px;
            font-size: 13px;
            letter-spacing: 0.5px;
            cursor: pointer;
            border-radius: 6px;
            transition: 0.25s;
            display: none;
            box-shadow: 0 0 6px rgba(76,243,255,0.12);
        }
        #back-to-earth-btn:hover {
            background-color: rgba(76,243,255,0.08);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="info">
        <p id="loading-status">Initialising...</p>
        <button onclick="flyToCity('SÃO PAULO')" style="margin-top: 10px;">Fly to SÃO PAULO</button>
        <button onclick="flyToCity('LONDON')">Fly to LONDON</button>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="controls-container">
        <button id="back-to-earth-btn" onclick="flyToHomeAndUnzoom()"> &lt; Back to Earth </button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // 전역 변수
        let scene, camera, renderer, controls;
        let earthModel = null;
        let isFlying = false; 
        const flySpeed = 0.06; 
        const cityPoints = [];
        const EARTH_RADIUS = 1.2; 
        const INITIAL_CAMERA_Z = 3.0;
        const ZOOMED_CAMERA_Z = 2.0;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let currentlyZoomedCityName = null; // 현재 확대된 도시 이름을 저장
        // --- pointer click 판단용 ---
        let pointerDown = false;
        let pointerDownPos = { x: 0, y: 0 };
        const CLICK_THRESHOLD = 6; // 픽셀 단위
        
        // --- 1. Lat/Lon 좌표 변환 ---
        function latLonToVector3(lat, lon, radius = EARTH_RADIUS) {
            const phi = (90 - lat) * (Math.PI / 180); 
            const theta = (lon + 180) * (Math.PI / 180); 

            const x = -((radius) * Math.sin(phi) * Math.cos(theta));
            const z = ((radius) * Math.sin(phi) * Math.sin(theta));
            const y = ((radius) * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        // --- 2. 초기화 ---
        function init() {
            const canvasContainer = document.body;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, INITIAL_CAMERA_Z);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1.5;
            controls.maxDistance = 10;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = -1.0; 

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.12); 
            scene.add(ambientLight);

            createEarthSphere(); 
            createDataPoints(EARTH_RADIUS); 

            window.addEventListener('resize', onWindowResize);

            // Pointer 이벤트로 클릭 판단 (드래그와 구분)
            renderer.domElement.addEventListener('pointerdown', (e) => {
                pointerDown = true;
                pointerDownPos.x = e.clientX;
                pointerDownPos.y = e.clientY;
            });
            renderer.domElement.addEventListener('pointerup', (e) => {
                if (!pointerDown) return;
                pointerDown = false;
                const dx = Math.abs(e.clientX - pointerDownPos.x);
                const dy = Math.abs(e.clientY - pointerDownPos.y);
                if (dx <= CLICK_THRESHOLD && dy <= CLICK_THRESHOLD) {
                    // 실제 '클릭'으로 처리
                    handleCanvasClick(e);
                }
            });

            // expose functions to global
            window.flyToCity = flyToCity;
            window.flyToHomeAndUnzoom = flyToHomeAndUnzoom;
        }
        
        // --- 3. 지구본 생성 ---
        function createEarthSphere() {
            updateLoadingStatus('Loading earth texture...');
            
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load(
                'earth_texture.jpg', 
                () => {
                    updateLoadingStatus('Earth texture loaded!');
                    setTimeout(() => updateLoadingStatus(''), 800);
                },
                undefined,
                (error) => {
                    console.error('Error loading texture:', error);
                    updateLoadingStatus('Error loading texture (Check file name: earth_texture.jpg)');
                }
            );

            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            
            const material = new THREE.MeshBasicMaterial({ 
                map: earthTexture,
            });
            
            earthModel = new THREE.Mesh(geometry, material);
            scene.add(earthModel);
        }

        // --- 4. 도시 포인트 및 라벨 ---
        const citiesData = [
            { lat: 51.5, lon: -0.1, name: 'LONDON' },
            { lat: -23.5, lon: -46.6, name: 'SÃO PAULO' },
            { lat: 40.7, lon: -74.0, name: 'NEW YORK' },
        ];

        function createDataPoints(earthRadius) {
            citiesData.forEach(city => {
                const pos = latLonToVector3(city.lat, city.lon, earthRadius * 1.002); 
                
                const pointGeometry = new THREE.SphereGeometry(0.008, 16, 16); 
                const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x4cf3ff });
                const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
                
                pointMesh.position.copy(pos);
                pointMesh.userData = { isCityPoint: true, name: city.name, lat: city.lat, lon: city.lon };
                scene.add(pointMesh);
                cityPoints.push(pointMesh);

                addHTMLLabel(city.name, pointMesh.id);
            });
        }

        function addHTMLLabel(name, meshId) {
            const label = document.createElement('div');
            label.className = 'city-label';
            label.id = `label-${meshId}`;
            label.textContent = name;
            document.body.appendChild(label);
            
            // label 클릭은 DOM 상에서의 클릭이므로 화면 좌표 클릭과 분리
            label.addEventListener('click', (e) => {
                e.stopPropagation();
                flyToCity(name);
            });
        }

        // --- 5. Fly home (Back to Earth) ---
        function flyToHomeAndUnzoom() {
            if (currentlyZoomedCityName === null) return; 

            // 비행 시작: disable controls to avoid user interaction during flight
            controls.enabled = false;
            controls.autoRotate = false; // disable while flying back to avoid interference

            const origin = new THREE.Vector3(0, 0, 0);
            const zoomOutCameraPos = new THREE.Vector3(0, 0, INITIAL_CAMERA_Z);
            
            isFlying = true;
            camera.userData.targetPos = zoomOutCameraPos;
            camera.userData.targetLookAt = origin;

            // 상태 초기화 — 자동회전은 애니메이션 종결 시 복구
            currentlyZoomedCityName = null;
            // 버튼 visibility handled in animate()
        }

        // --- 6. Fly to city (zoom in) ---
        function flyToCity(cityName) {
            // toggle: same city clicked -> zoom out
            if (currentlyZoomedCityName === cityName) {
                flyToHomeAndUnzoom();
                return;
            }

            const targetCity = citiesData.find(c => c.name === cityName);
            if (!targetCity) return;

            // 비행 시작: disable controls while flying
            controls.enabled = false;
            controls.autoRotate = false;

            const targetLookAt = latLonToVector3(targetCity.lat, targetCity.lon, 0);
            // camera target pos: slightly away from surface along same vector (ZOOMED_CAMERA_Z)
            const targetVector = latLonToVector3(targetCity.lat, targetCity.lon, ZOOMED_CAMERA_Z);

            isFlying = true;
            camera.userData.targetPos = targetVector;
            camera.userData.targetLookAt = targetLookAt;

            currentlyZoomedCityName = cityName;
            // 버튼 visibility handled in animate()
        }
        
        // --- 7. Canvas 클릭 처리 (pointerup에서 호출) ---
        function handleCanvasClick(event) {
            // renderer.domElement is full-window; get client coords from event
            const rect = renderer.domElement.getBoundingClientRect();
            const clientX = event.clientX - rect.left;
            const clientY = event.clientY - rect.top;

            mouse.x = (clientX / rect.width) * 2 - 1;
            mouse.y = -(clientY / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // only test cityPoints
            const intersects = raycaster.intersectObjects(cityPoints, true);

            if (intersects.length > 0) {
                const clickedPoint = intersects[0].object;
                if (clickedPoint.userData && clickedPoint.userData.isCityPoint) {
                    flyToCity(clickedPoint.userData.name);
                }
            } else {
                // 빈 공간 클릭 시: 줌아웃 대신 버튼 사용 권장 (여기선 아무 동작 안함)
            }
        }

        // --- 8. 애니메이션 루프 ---
        function animate() {
            requestAnimationFrame(animate);

            if (isFlying && camera.userData && camera.userData.targetPos && camera.userData.targetLookAt) {
                // 부드러운 이동
                camera.position.lerp(camera.userData.targetPos, flySpeed);
                controls.target.lerp(camera.userData.targetLookAt, flySpeed);

                const distance = camera.position.distanceTo(camera.userData.targetPos);
                // 카메라 이동이 거의 끝나면 비행 종료
                if (distance < 0.03) {
                    isFlying = false;

                    // 컨트롤 복구
                    controls.enabled = true;

                    // 만약 현재 확대 상태가 없으면(=홈 복귀 상태) 자동회전 복구
                    if (currentlyZoomedCityName === null) {
                        controls.autoRotate = true;
                    } else {
                        // 확대된 상태면 자동회전은 끈 채로 유지
                        controls.autoRotate = false;
                        // 컨트롤의 target을 중심으로 살짝 offset하여 마우스가 즉시 드래그되는 것을 방지
                        controls.target.copy(camera.userData.targetLookAt);
                    }
                }
            }

            // OrbitControls 자동 회전 수행 (controls.update 내부에서 처리)
            controls.update();

            // 라벨 위치 업데이트
            updateHTMLLabels();

            // Back 버튼 보이기/숨기기
            const backBtn = document.getElementById('back-to-earth-btn');
            if (backBtn) {
                backBtn.style.display = currentlyZoomedCityName ? 'block' : 'none';
            }

            renderer.render(scene, camera);
        }

        // --- 9. HTML 라벨 위치 업데이트 ---
        function updateHTMLLabels() {
            cityPoints.forEach(mesh => {
                const label = document.getElementById(`label-${mesh.id}`);
                if (!label) return;

                const meshPosition = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);

                const normalVector = meshPosition.clone().normalize(); 
                const meshToCamera = new THREE.Vector3().subVectors(camera.position, meshPosition).normalize();
                
                const dotProduct = normalVector.dot(meshToCamera); 
                
                const isFacingCamera = dotProduct > 0.0; 

                const vector = meshPosition.clone().project(camera);

                if (isFacingCamera) { 
                    label.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                    label.style.top = `${(-vector.y * 0.5 + 0.5) * window.innerHeight}px`;
                    
                    label.style.opacity = Math.min(1, Math.max(0, dotProduct * 5)); 
                } else {
                    label.style.opacity = 0;
                }
            });
        }


        // --- 10. 기타 유틸리티 ---
        function updateLoadingStatus(message) {
            const info = document.getElementById('loading-status');
            if (info) {
                info.style.color = message.includes('Error') ? '#ff6b6b' : '#4ecdc4';
                info.textContent = message;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.addEventListener('DOMContentLoaded', () => {
            init();
            animate();
        });
    </script>
</body>
</html>